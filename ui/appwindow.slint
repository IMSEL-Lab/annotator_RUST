import { VerticalBox, HorizontalBox } from "std-widgets.slint";

struct PolygonVertex {
    x: float,
    y: float,
}

struct Annotation {
    id: int,
    type: string,
    x: float,
    y: float,
    width: float,
    height: float,
    rotation: float,
    selected: bool,
    class: int,  // Classification: 1-999 for multi-digit support
    vertices: string,  // For polygons: "x1,y1;x2,y2;x3,y3" format
    polygon-vertices: [PolygonVertex],  // Parsed vertices for rendering
    polygon-path-commands: string,  // SVG path commands for rendering edges
}

export component AppWindow inherits Window {
    title: "Annotator v0";
    min-width: 800px;
    min-height: 600px;

    in property <string> status-text: "Ready";
    callback log-debug(string);
    in property <image> image-source;
    in property <[Annotation]> annotations;
    callback select-annotation(int);
    callback deselect-all();
    callback next-image();
    callback prev-image();

    // Phase 4: Tool state and input
    in-out property <string> current-tool: "Neutral";
    in-out property <int> current-class: 1;
    in-out property <bool> q-key-held: false;
    in-out property <bool> digit-key-held: false;  // True when any digit 1-5 is held
    in-out property <bool> a-key-held: false;      // Track A key for auto-resize gesture
    in-out property <string> current-image-name: "";
    in-out property <string> dataset-position: ""; // e.g., "1 / 3"

    // Phase 4: Drawing preview
    in-out property <bool> show-preview: false;
    in-out property <float> preview-x;
    in-out property <float> preview-y;
    in-out property <float> preview-width;
    in-out property <float> preview-height;

    // Phase 4: Polygon mode
    in-out property <bool> polygon-mode-active: false;
    in-out property <bool> s-key-held: false;  // Track S key hold for polygon workflow
    in-out property <string> polygon-preview-vertices: "";  // Current vertices being collected
    in-out property <string> polygon-preview-path: "";  // SVG path for preview lines

    // Phase 3: Resize state
    in-out property <bool> is-resizing: false;

    // Helper to generate SVG path commands from vertices string
    pure function generate-polygon-path(vertices-str: string) -> string {
        // This will be populated from Rust with proper SVG path commands
        vertices-str
    }

    // Phase 4: Callbacks for tool actions
    callback start-drawing(float, float);  // Mouse press in image coords
    callback update-drawing(float, float); // Mouse move in image coords
    callback finish-drawing(float, float); // Mouse release in image coords
    callback cancel-drawing();
    callback delete-annotation-at(float, float); // Image coords
    callback delete-annotation(int); // Delete annotation by index
    callback classify-at(float, float, int);  // Image coords + class
    callback classify-selected(int);  // Reclassify currently selected annotation(s)
    callback auto-resize-annotation(float, float, string); // (img-x, img-y, gesture-kind)
    callback add-polygon-vertex(float, float);  // Add vertex to current polygon
    callback finish-polygon();  // Complete and create polygon annotation
    callback cancel-polygon();  // Cancel polygon creation

    // Phase 3: Resize callbacks
    callback start-resize(int, string);  // (annotation index, handle type: "corner-tl", "corner-tr", "corner-bl", "corner-br", "edge-t", "edge-r", "edge-b", "edge-l")
    callback update-resize(float, float);  // Image coords during drag
    callback finish-resize();  // Complete resize operation

    VerticalBox {
        preferred-width: 1200px;
        preferred-height: 800px;
        padding: 0px;
        spacing: 0px;

        // Top Bar
        Rectangle {
            height: 40px;
            background: #333333;
            HorizontalLayout {
                padding: 8px;
                spacing: 12px;
                Text {
                    text: "Annotator";
                    color: white;
                    font-size: 16px;
                    vertical-alignment: center;
                }

                Rectangle {
                    width: 1px;
                    height: 24px;
                    background: #555555;
                }

                Text {
                    text: root.dataset-position == "" ? "No dataset" : root.dataset-position;
                    color: #AAAAAA;
                    font-size: 14px;
                    vertical-alignment: center;
                }

                Text {
                    text: root.current-image-name;
                    color: #CCCCCC;
                    font-size: 14px;
                    vertical-alignment: center;
                    horizontal-alignment: left;
                }

                HorizontalLayout {
                    spacing: 4px;
                    Rectangle {
                        width: 26px;
                        height: 20px;
                        background: #555555;
                        border-radius: 3px;
                        Text {
                            text: "<";
                            color: white;
                            horizontal-alignment: center;
                            vertical-alignment: center;
                        }

                        TouchArea {
                            clicked => {
                                root.prev-image();
                            }
                        }
                    }

                    Rectangle {
                        width: 26px;
                        height: 20px;
                        background: #555555;
                        border-radius: 3px;
                        Text {
                            text: ">";
                            color: white;
                            horizontal-alignment: center;
                            vertical-alignment: center;
                        }

                        TouchArea {
                            clicked => {
                                root.next-image();
                            }
                        }
                    }
                }
            }
        }

        // Middle Section
        HorizontalBox {
            padding: 0px;
            spacing: 0px;
            
            // Left Sidebar
            Rectangle {
                width: 200px;
                background: #444444;
                Text {
                    text: "Classes / Tools";
                    color: white;
                    horizontal-alignment: center;
                    y: 10px;
                }
            }

            // Central Canvas
            image-container := Rectangle {
                background: #222222;
                clip: true;

                property <float> fit-scale: (root.image-source.width > 0 && root.image-source.height > 0) ? min(self.width / (root.image-source.width * 1px), self.height / (root.image-source.height * 1px)) : 1.0;

                in-out property <float> zoom-level: fit-scale;
                in-out property <length> pan-x: (self.width - (root.image-source.width * 1px * self.zoom-level)) / 2;
                in-out property <length> pan-y: (self.height - (root.image-source.height * 1px * self.zoom-level)) / 2;

                Image {
                    source: root.image-source;
                    x: image-container.pan-x;
                    y: image-container.pan-y;
                    width: self.source.width * 1px * image-container.zoom-level;
                    height: self.source.height * 1px * image-container.zoom-level;
                }

                TouchArea {
                    width: 100%;
                    height: 100%;

                    property <length> start-pan-x;
                    property <length> start-pan-y;
                    property <bool> is-drawing: false;

                    pointer-event(event) => {
                        if (event.button == PointerEventButton.left) {
                            if (event.kind == PointerEventKind.down) {
                                // Auto-resize gesture: A + click anywhere in image
                                if (root.a-key-held) {
                                    let img-x = (self.mouse-x - image-container.pan-x) / image-container.zoom-level / 1px;
                                    let img-y = (self.mouse-y - image-container.pan-y) / image-container.zoom-level / 1px;
                                    root.auto-resize-annotation(img-x, img-y, "AClick");
                                }
                                // Check if polygon mode is active
                                else if (root.polygon-mode-active) {
                                    // Add vertex to polygon - convert screen to image coords
                                    let img-x = (self.mouse-x - image-container.pan-x) / image-container.zoom-level / 1px;
                                    let img-y = (self.mouse-y - image-container.pan-y) / image-container.zoom-level / 1px;
                                    root.add-polygon-vertex(img-x, img-y);
                                }
                                // Check if a drawing tool is active
                                else if (root.current-tool != "Neutral") {
                                    // Start drawing - convert screen to image coords
                                    let img-x = (self.mouse-x - image-container.pan-x) / image-container.zoom-level / 1px;
                                    let img-y = (self.mouse-y - image-container.pan-y) / image-container.zoom-level / 1px;
                                    root.start-drawing(img-x, img-y);
                                    self.is-drawing = true;
                                } else if (root.q-key-held) {
                                    // Delete mode - convert coords and trigger delete
                                    let img-x = (self.mouse-x - image-container.pan-x) / image-container.zoom-level / 1px;
                                    let img-y = (self.mouse-y - image-container.pan-y) / image-container.zoom-level / 1px;
                                    root.delete-annotation-at(img-x, img-y);
                                } else {
                                    // Normal pan behavior
                                    self.start-pan-x = image-container.pan-x;
                                    self.start-pan-y = image-container.pan-y;
                                    root.deselect-all();
                                }
                            } else if (event.kind == PointerEventKind.up && self.is-drawing) {
                                // Finish drawing
                                let img-x = (self.mouse-x - image-container.pan-x) / image-container.zoom-level / 1px;
                                let img-y = (self.mouse-y - image-container.pan-y) / image-container.zoom-level / 1px;
                                root.finish-drawing(img-x, img-y);
                                self.is-drawing = false;
                            }
                        }
                    }

                    moved => {
                        if (self.pressed && self.is-drawing) {
                            // Update drawing preview
                            let img-x = (self.mouse-x - image-container.pan-x) / image-container.zoom-level / 1px;
                            let img-y = (self.mouse-y - image-container.pan-y) / image-container.zoom-level / 1px;
                            root.update-drawing(img-x, img-y);
                        } else if (self.pressed && root.current-tool == "Neutral" && !root.q-key-held) {
                            // Pan behavior
                            image-container.pan-x = self.start-pan-x + (self.mouse-x - self.pressed-x);
                            image-container.pan-y = self.start-pan-y + (self.mouse-y - self.pressed-y);
                        }
                    }

                    scroll-event(event) => {
                        if (event.delta-y != 0) {
                            let old-zoom = image-container.zoom-level;
                            let zoom-factor = 1.1;
                            let next-zoom = event.delta-y > 0 ? old-zoom * zoom-factor : old-zoom / zoom-factor;
                            
                            // Clamp zoom
                            let clamped-zoom = max(0.1, min(next-zoom, 10.0));
                            
                            // Zoom centered on cursor
                            let mouse-x-rel = self.mouse-x - image-container.pan-x;
                            let mouse-y-rel = self.mouse-y - image-container.pan-y;
                            image-container.pan-x = self.mouse-x - mouse-x-rel * (clamped-zoom / old-zoom);
                            image-container.pan-y = self.mouse-y - mouse-y-rel * (clamped-zoom / old-zoom);
                            image-container.zoom-level = clamped-zoom;
                            return accept;
                        }
                        reject
                    }
                }

                // Preview rectangle while drawing
                if root.show-preview: Rectangle {
                    x: image-container.pan-x + (root.preview-x * 1px * image-container.zoom-level);
                    y: image-container.pan-y + (root.preview-y * 1px * image-container.zoom-level);
                    width: root.preview-width * 1px * image-container.zoom-level;
                    height: root.preview-height * 1px * image-container.zoom-level;
                    border-width: 2px;
                    border-color: #00FFFF;  // Cyan for preview
                    background: #00FFFF20;  // Translucent cyan
                }

                // Polygon mode indicator
                if root.polygon-mode-active: Rectangle {
                    x: 10px;
                    y: 50px;
                    width: 280px;
                    height: 40px;
                    background: #FF00FF;
                    border-radius: 5px;

                    Text {
                        text: "POLYGON MODE (Hold S) - Click vertices, release S/Tab/Enter to finish, Esc to cancel";
                        color: white;
                        font-size: 10px;
                        horizontal-alignment: center;
                        vertical-alignment: center;
                    }
                }

                // Polygon preview - show lines as vertices are being added
                if root.polygon-mode-active && root.polygon-preview-path != "": Rectangle {
                    background: #00000000;
                    width: 100%;
                    height: 100%;

                    Path {
                        viewbox-width: root.image-source.width;
                        viewbox-height: root.image-source.height;
                        x: image-container.pan-x;
                        y: image-container.pan-y;
                        width: root.image-source.width * 1px * image-container.zoom-level;
                        height: root.image-source.height * 1px * image-container.zoom-level;

                        stroke: #FFFF00;  // Yellow for preview
                        stroke-width: 2px;
                        fill: transparent;

                        commands: root.polygon-preview-path;
                    }
                }

                // Annotation Overlay
                for annotation[index] in root.annotations: annotation-rect := Rectangle {
                    background: #00000000; // Transparent
                    width: 100%;
                    height: 100%;
                    
                    // Calculate screen coordinates
                    property <length> screen-x: image-container.pan-x + (annotation.x * 1px * image-container.zoom-level);
                    property <length> screen-y: image-container.pan-y + (annotation.y * 1px * image-container.zoom-level);
                    property <length> screen-w: annotation.width * 1px * image-container.zoom-level;
                    property <length> screen-h: annotation.height * 1px * image-container.zoom-level;
                    
                    // Rotation properties
                    property <angle> rot: annotation.rotation * 1deg;
                    
                    // Center and Half-dims
                    property <length> cx: self.screen-x + self.screen-w / 2;
                    property <length> cy: self.screen-y + self.screen-h / 2;

                    // Selection Bounding Box (for TouchArea)
                    property <length> sel-w: annotation.type == "point" ? 20px : self.screen-w;
                    property <length> sel-h: annotation.type == "point" ? 20px : self.screen-h;

                    // Point (Circle)
                    Rectangle {
                        visible: annotation.type == "point";
                        x: annotation-rect.screen-x - 5px;
                        y: annotation-rect.screen-y - 5px;
                        width: 10px;
                        height: 10px;
                        border-radius: 5px;
                        background: annotation.selected ? #00FF00 : #FF0000;
                    }

                    // Standard BBox (Rectangle)
                    Rectangle {
                        visible: annotation.type == "bbox";
                        x: annotation-rect.screen-x;
                        y: annotation-rect.screen-y;
                        width: annotation-rect.screen-w;
                        height: annotation-rect.screen-h;
                        border-width: 2px;
                        border-color: annotation.selected ? #00FF00 : #FF0000;
                        background: #00000000;
                    }

                    // Rotated BBox (using transform-rotation)
                    Rectangle {
                        visible: annotation.type == "rbbox";
                        x: annotation-rect.screen-x;
                        y: annotation-rect.screen-y;
                        width: annotation-rect.screen-w;
                        height: annotation-rect.screen-h;
                        border-width: 2px;
                        border-color: annotation.selected ? #00FF00 : #FF0000;
                        background: #00000000;
                        transform-rotation: annotation-rect.rot;
                    }

                    // Polygon rendering - draw actual connected edges
                    if annotation.type == "polygon" && annotation.polygon-path-commands != "": Rectangle {
                        background: #00000000;
                        width: 100%;
                        height: 100%;

                        // Draw polygon with actual edges using Path
                        Path {
                            viewbox-width: root.image-source.width;
                            viewbox-height: root.image-source.height;
                            x: image-container.pan-x;
                            y: image-container.pan-y;
                            width: root.image-source.width * 1px * image-container.zoom-level;
                            height: root.image-source.height * 1px * image-container.zoom-level;

                            stroke: annotation.selected ? #00FF00 : #FF00FF;
                            stroke-width: 3px;
                            fill: #FF00FF20;  // Translucent magenta fill

                            // Use dynamically generated SVG path commands
                            commands: annotation.polygon-path-commands;
                        }

                        // Draw vertex dots for clarity
                        for vertex in annotation.polygon-vertices: Rectangle {
                            x: image-container.pan-x + (vertex.x * 1px * image-container.zoom-level) - 5px;
                            y: image-container.pan-y + (vertex.y * 1px * image-container.zoom-level) - 5px;
                            width: 10px;
                            height: 10px;
                            border-radius: 5px;
                            background: annotation.selected ? #00FF00 : #FF00FF;
                        }
                    }

                    // Class label (shows class number)
                    Rectangle {
                        x: annotation-rect.screen-x;
                        y: annotation-rect.screen-y - 20px;
                        width: 30px;
                        height: 18px;
                        background: annotation.selected ? #00FF00 : #FF0000;
                        border-radius: 3px;

                        Text {
                            text: annotation.class;
                            color: #000000;
                            font-size: 12px;
                            horizontal-alignment: center;
                            vertical-alignment: center;
                        }
                    }

                    // Resize handles (only for selected bbox/rbbox, not in polygon mode)
                    if annotation.selected && (annotation.type == "bbox" || annotation.type == "rbbox") && !root.polygon-mode-active: Rectangle {
                        property <length> handle-size: 8px;
                        property <length> half-handle: self.handle-size / 2;
                        background: #00000000;
                        width: 100%;
                        height: 100%;

                        // Corner handles
                        // Top-left
                        Rectangle {
                            x: annotation-rect.screen-x - parent.half-handle;
                            y: annotation-rect.screen-y - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: #00FF00;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: nwse-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "corner-tl");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }

                        // Top-right
                        Rectangle {
                            x: annotation-rect.screen-x + annotation-rect.screen-w - parent.half-handle;
                            y: annotation-rect.screen-y - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: #00FF00;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: nesw-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "corner-tr");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }

                        // Bottom-left
                        Rectangle {
                            x: annotation-rect.screen-x - parent.half-handle;
                            y: annotation-rect.screen-y + annotation-rect.screen-h - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: #00FF00;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: nesw-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "corner-bl");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }

                        // Bottom-right
                        Rectangle {
                            x: annotation-rect.screen-x + annotation-rect.screen-w - parent.half-handle;
                            y: annotation-rect.screen-y + annotation-rect.screen-h - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: #00FF00;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: nwse-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "corner-br");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }

                        // Edge handles
                        // Top edge
                        Rectangle {
                            x: annotation-rect.screen-x + annotation-rect.screen-w / 2 - parent.half-handle;
                            y: annotation-rect.screen-y - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: #00FF00;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: ns-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "edge-t");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }

                        // Right edge
                        Rectangle {
                            x: annotation-rect.screen-x + annotation-rect.screen-w - parent.half-handle;
                            y: annotation-rect.screen-y + annotation-rect.screen-h / 2 - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: #00FF00;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: ew-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "edge-r");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }

                        // Bottom edge
                        Rectangle {
                            x: annotation-rect.screen-x + annotation-rect.screen-w / 2 - parent.half-handle;
                            y: annotation-rect.screen-y + annotation-rect.screen-h - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: #00FF00;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: ns-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "edge-b");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }

                        // Left edge
                        Rectangle {
                            x: annotation-rect.screen-x - parent.half-handle;
                            y: annotation-rect.screen-y + annotation-rect.screen-h / 2 - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: #00FF00;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: ew-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "edge-l");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }
                    }

                    // Only intercept clicks when NOT in polygon mode
                    if !root.polygon-mode-active: TouchArea {
                        x: annotation-rect.cx - annotation-rect.sel-w / 2;
                        y: annotation-rect.cy - annotation-rect.sel-h / 2;
                        width: annotation-rect.sel-w;
                        height: annotation-rect.sel-h;
                        clicked => {
                            if (root.a-key-held) {
                                // Auto-resize gesture directly on annotation hit area
                                let img-x = (self.mouse-x + self.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                let img-y = (self.mouse-y + self.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                root.auto-resize-annotation(img-x, img-y, "AClick");
                            } else if (root.q-key-held) {
                                // Delete mode
                                root.delete-annotation(index);
                            } else if (root.digit-key-held) {
                                // Reclassify mode - change annotation's class
                                root.classify-at(annotation.x, annotation.y, root.current-class);
                            } else {
                                // Normal mode - select annotation
                                root.select-annotation(index);
                            }
                        }
                        double-clicked => {
                            root.delete-annotation(index);
                        }
                    }
                }
            }
        }

        // Bottom Status Bar
        Rectangle {
            height: 30px;
            background: #333333;
            HorizontalLayout {
                padding: 5px;
                spacing: 20px;
                Text {
                    text: root.status-text;
                    color: white;
                    font-size: 12px;
                    vertical-alignment: center;
                }

                Text {
                    text: "Tool: " + root.current-tool;
                    color: root.current-tool == "Neutral" ? #888888 : #00FF00;
                    font-size: 12px;
                    vertical-alignment: center;
                }

                Text {
                    text: "Class: " + root.current-class;
                    color: #FFAA00;
                    font-size: 12px;
                    vertical-alignment: center;
                }
            }
        }
    }

    // Keyboard handler (must be at root level)
    FocusScope {
        key-pressed(event) => {
            if (event.text == "b" || event.text == "B") {
                root.current-tool = "BBox (B)";
                accept
            } else if (event.text == "c" || event.text == "C") {
                root.current-tool = "Point (C)";
                accept
            } else if (event.text == "a" || event.text == "A") {
                root.a-key-held = true;
                accept
            } else if (event.text == "s" || event.text == "S") {
                            // S key press: activate polygon mode while held
                            if (!root.polygon-mode-active) {
                    root.polygon-mode-active = true;
                    root.current-tool = "Polygon (Hold S)";
                }
                root.s-key-held = true;
                accept
            } else if (event.text == "q" || event.text == "Q") {
                            // Cancel polygon if in mode, otherwise hold for delete
                if (root.polygon-mode-active) {
                    root.cancel-polygon();
                } else {
                    root.q-key-held = true;
                }
                accept
            } else if (event.text == "1") {
                root.current-class = 1;
                root.classify-selected(root.current-class);
                root.digit-key-held = true;
                accept
            } else if (event.text == "2") {
                root.current-class = 2;
                root.classify-selected(root.current-class);
                root.digit-key-held = true;
                accept
            } else if (event.text == "3") {
                root.current-class = 3;
                root.classify-selected(root.current-class);
                root.digit-key-held = true;
                accept
            } else if (event.text == "4") {
                root.current-class = 4;
                root.classify-selected(root.current-class);
                root.digit-key-held = true;
                accept
            } else if (event.text == "5") {
                root.current-class = 5;
                root.classify-selected(root.current-class);
                root.digit-key-held = true;
                accept
            } else if (event.text == "\n") {
                // Enter key - finish polygon
                if (root.polygon-mode-active) {
                    root.finish-polygon();
                    if (root.s-key-held) {
                        // Keep mode active while S is held
                        root.polygon-mode-active = true;
                        root.current-tool = "Polygon (Hold S)";
                    }
                    accept
                }
                reject
            } else if (event.text == "\u{0009}") {
                // Tab key - finish polygon
                if (root.polygon-mode-active) {
                    root.finish-polygon();
                    if (root.s-key-held) {
                        // Keep mode active while S is held
                        root.polygon-mode-active = true;
                        root.current-tool = "Polygon (Hold S)";
                    }
                    accept
                }
                reject
            } else if (event.text == "\u{001b}") {
                // Escape key - cancel polygon or exit polygon mode
                if (root.polygon-mode-active) {
                    root.cancel-polygon();
                }
                accept
            }
            reject
        }

        key-released(event) => {
            if (event.text == "b" || event.text == "B" || event.text == "c" || event.text == "C") {
                root.current-tool = "Neutral";
                accept
            } else if (event.text == "a" || event.text == "A") {
                root.a-key-held = false;
                accept
            } else if (event.text == "s" || event.text == "S") {
                    // S key release: finish any in-progress polygon and exit mode
                    if (root.polygon-mode-active) {
                    root.finish-polygon();
                }
                root.polygon-mode-active = false;
                root.current-tool = "Neutral";
                root.s-key-held = false;
                accept
            } else if (event.text == "q" || event.text == "Q") {
                root.q-key-held = false;
                accept
            } else if (event.text == "1" || event.text == "2" || event.text == "3" || event.text == "4" || event.text == "5") {
                root.digit-key-held = false;
                accept
            }
            reject
        }
    }
}
