import { VerticalBox, HorizontalBox } from "std-widgets.slint";
import { Theme } from "theme.slint";
import { MenuBar } from "components/menubar.slint";
import { Sidebar, ClassItem } from "components/sidebar.slint";
import { SettingsDialog } from "components/dialogs/settings_dialog.slint";

struct PolygonVertex {
    x: float,
    y: float,
}

struct Annotation {
    id: int,
    type: string,
    x: float,
    y: float,
    width: float,
    height: float,
    rotation: float,
    selected: bool,
    class: int,  // Classification: 1-999 for multi-digit support
    state: string, // Pending | Accepted | Rejected | Manual
    vertices: string,  // For polygons: "x1,y1;x2,y2;x3,y3" format
    polygon-vertices: [PolygonVertex],  // Parsed vertices for rendering
    polygon-path-commands: string,  // SVG path commands for rendering edges
}

export component AppWindow inherits Window {
    title: "Annotator v0";
    min-width: 800px;
    min-height: 600px;
    background: Theme.current.bg-dark;

    in property <string> status-text: "Ready";
    callback log-debug(string);
    in property <image> image-source;
    in property <[Annotation]> annotations;
    callback select-annotation(int);
    callback deselect-all();
    callback next-image();
    callback prev-image();

    // Phase 4: Tool state and input
    in-out property <string> current-tool: "Neutral";
    in-out property <int> current-class: 1;
    in-out property <bool> q-key-held: false;
    in-out property <bool> digit-key-held: false;  // True when any digit 1-5 is held
    in-out property <bool> a-key-held: false;      // Track A key for auto-resize gesture
    in-out property <string> current-image-name: "";
    in-out property <string> dataset-position: ""; // e.g., "1 / 3"

    // Phase 4: Drawing preview
    in-out property <bool> show-preview: false;
    in-out property <float> preview-x;
    in-out property <float> preview-y;
    in-out property <float> preview-width;
    in-out property <float> preview-height;

    // Phase 4: Polygon mode
    in-out property <bool> polygon-mode-active: false;
    in-out property <bool> s-key-held: false;  // Track S key hold for polygon workflow
    in-out property <string> polygon-preview-vertices: "";  // Current vertices being collected
    in-out property <string> polygon-preview-path: "";  // SVG path for preview lines

    // Phase 3: Resize state
    in-out property <bool> is-resizing: false;

    // Phase 5C: per-image view memory
    in-out property <float> view-pan-x: 0.0;
    in-out property <float> view-pan-y: 0.0;
    in-out property <float> view-zoom: 1.0;
    callback reset-view();
    callback apply-zoom-centered(float);
    callback view-changed(float, float, float);
    callback save-dataset();

    // Phase 4: Dataset management
    callback open-dataset();
    callback new-dataset();

    // Phase 5: Export system
    callback export-coco();
    callback export-voc();

    // Phase 2: Class management
    in property <[ClassItem]> class-items;
    callback get-class-name(int) -> string;

    // Phase 2: Sidebar
    in-out property <bool> sidebar-visible: true;
    in-out property <length> sidebar-width: 250px;

    // Menu dropdown state
    in-out property <string> open-menu: "";

    // Phase 3: Settings
    in-out property <bool> settings-dialog-visible: false;
    in-out property <string> theme-setting: "dark";
    in-out property <bool> enable-points-setting: true;
    in-out property <bool> enable-bboxes-setting: true;
    in-out property <bool> enable-polygons-setting: true;
    in-out property <bool> randomize-dataset-setting: false;
    callback apply-settings(string, bool, bool, bool, bool);  // theme, points, bboxes, polygons, randomize

    // Helper to generate SVG path commands from vertices string
    pure function generate-polygon-path(vertices-str: string) -> string {
        // This will be populated from Rust with proper SVG path commands
        vertices-str
    }

    // Phase 4: Callbacks for tool actions
    callback start-drawing(float, float);  // Mouse press in image coords
    callback update-drawing(float, float); // Mouse move in image coords
    callback finish-drawing(float, float); // Mouse release in image coords
    callback cancel-drawing();
    callback delete-annotation-at(float, float); // Image coords
    callback delete-annotation(int); // Delete annotation by index
    callback classify-at(float, float, int);  // Image coords + class
    callback classify-selected(int);  // Reclassify currently selected annotation(s)
    callback auto-resize-annotation(float, float, string); // (img-x, img-y, gesture-kind)
    callback add-polygon-vertex(float, float);  // Add vertex to current polygon
    callback finish-polygon();  // Complete and create polygon annotation
    callback cancel-polygon();  // Cancel polygon creation

    // Phase 3: Resize callbacks
    callback start-resize(int, string);  // (annotation index, handle type: "corner-tl", "corner-tr", "corner-bl", "corner-br", "edge-t", "edge-r", "edge-b", "edge-l")
    callback update-resize(float, float);  // Image coords during drag
    callback finish-resize();  // Complete resize operation

    VerticalLayout {
        padding: 0px;
        spacing: 0px;

        // Menu Bar
        MenuBar {
            open-menu <=> root.open-menu;
            file-open-dataset => {
                root.open-dataset();
            }
            file-new-dataset => {
                root.new-dataset();
            }
            file-save => {
                root.save-dataset();
            }
            file-export-coco => {
                root.export-coco();
            }
            file-export-voc => {
                root.export-voc();
            }
            view-reset => {
                root.reset-view();
            }
            view-toggle-sidebar => {
                root.sidebar-visible = !root.sidebar-visible;
            }
            view-theme-dark => {
                Theme.set-theme("dark");
            }
            view-theme-light => {
                Theme.set-theme("light");
            }
            tools-settings => {
                root.settings-dialog-visible = true;
            }
        }

        // Main content area
        HorizontalLayout {
            padding: 0px;
            spacing: 0px;

            // Left Sidebar
            Sidebar {
                classes: root.class-items;
                current-class: root.current-class;
                current-tool: root.current-tool;
                show-sidebar: root.sidebar-visible;
                sidebar-width: root.sidebar-width;
                class-selected(id) => {
                    root.current-class = id;
                }
            }

            // Central Canvas
            image-container := Rectangle {
                horizontal-stretch: 1;  // Take all remaining space
                background: Theme.current.bg-dark;
                clip: true;

                property <float> fit-scale: {
                    let base = (root.image-source.width > 0 && root.image-source.height > 0) ? min(self.width / (root.image-source.width * 1px), self.height / (root.image-source.height * 1px)) : 1.0;
                    max(0.1, base)
                };

                in-out property <float> zoom-level <=> root.view-zoom;
                in-out property <float> pan-x-raw <=> root.view-pan-x;
                in-out property <float> pan-y-raw <=> root.view-pan-y;
                property <length> pan-x: self.pan-x-raw * 1px;
                property <length> pan-y: self.pan-y-raw * 1px;

                Image {
                    source: root.image-source;
                    x: image-container.pan-x;
                    y: image-container.pan-y;
                    width: self.source.width * 1px * image-container.zoom-level;
                    height: self.source.height * 1px * image-container.zoom-level;
                }

                TouchArea {
                    width: 100%;
                    height: 100%;

                    property <length> start-pan-x;
                    property <length> start-pan-y;
                    property <bool> is-drawing: false;

                    pointer-event(event) => {
                        if (event.button == PointerEventButton.left) {
                            if (event.kind == PointerEventKind.down) {
                                // Auto-resize gesture: A + click anywhere in image
                                if (root.a-key-held) {
                                    let img-x = (self.mouse-x - image-container.pan-x) / image-container.zoom-level / 1px;
                                    let img-y = (self.mouse-y - image-container.pan-y) / image-container.zoom-level / 1px;
                                    root.auto-resize-annotation(img-x, img-y, "AClick");
                                }
                                // Check if polygon mode is active
                                else if (root.polygon-mode-active) {
                                    // Add vertex to polygon - convert screen to image coords
                                    let img-x = (self.mouse-x - image-container.pan-x) / image-container.zoom-level / 1px;
                                    let img-y = (self.mouse-y - image-container.pan-y) / image-container.zoom-level / 1px;
                                    root.add-polygon-vertex(img-x, img-y);
                                }
                                // Check if a drawing tool is active
                                else if (root.current-tool != "Neutral") {
                                    // Start drawing - convert screen to image coords
                                    let img-x = (self.mouse-x - image-container.pan-x) / image-container.zoom-level / 1px;
                                    let img-y = (self.mouse-y - image-container.pan-y) / image-container.zoom-level / 1px;
                                    root.start-drawing(img-x, img-y);
                                    self.is-drawing = true;
                                } else if (root.q-key-held) {
                                    // Delete mode - convert coords and trigger delete
                                    let img-x = (self.mouse-x - image-container.pan-x) / image-container.zoom-level / 1px;
                                    let img-y = (self.mouse-y - image-container.pan-y) / image-container.zoom-level / 1px;
                                    root.delete-annotation-at(img-x, img-y);
                                } else {
                                    // Normal pan behavior
                                    self.start-pan-x = image-container.pan-x;
                                    self.start-pan-y = image-container.pan-y;
                                    root.deselect-all();
                                }
                            } else if (event.kind == PointerEventKind.up && self.is-drawing) {
                                // Finish drawing
                                let img-x = (self.mouse-x - image-container.pan-x) / image-container.zoom-level / 1px;
                                let img-y = (self.mouse-y - image-container.pan-y) / image-container.zoom-level / 1px;
                                root.finish-drawing(img-x, img-y);
                                self.is-drawing = false;
                            }
                        }
                    }

                    moved => {
                        if (self.pressed && self.is-drawing) {
                            // Update drawing preview
                            let img-x = (self.mouse-x - image-container.pan-x) / image-container.zoom-level / 1px;
                            let img-y = (self.mouse-y - image-container.pan-y) / image-container.zoom-level / 1px;
                            root.update-drawing(img-x, img-y);
                        } else if (self.pressed && root.current-tool == "Neutral" && !root.q-key-held) {
                            // Pan behavior
                            image-container.pan-x-raw = (self.start-pan-x + (self.mouse-x - self.pressed-x)) / 1px;
                            image-container.pan-y-raw = (self.start-pan-y + (self.mouse-y - self.pressed-y)) / 1px;
                            root.view-changed(image-container.pan-x-raw, image-container.pan-y-raw, image-container.zoom-level);
                        }
                    }

                    scroll-event(event) => {
                        if (event.delta-y != 0) {
                            let old-zoom = image-container.zoom-level;
                            let zoom-factor = 1.1;
                            let next-zoom = event.delta-y > 0 ? old-zoom * zoom-factor : old-zoom / zoom-factor;
                            
                            // Clamp zoom
                            let clamped-zoom = max(0.1, min(next-zoom, 10.0));
                            
                            // Zoom centered on cursor
                            let mouse-x-rel = self.mouse-x - image-container.pan-x;
                            let mouse-y-rel = self.mouse-y - image-container.pan-y;
                            image-container.pan-x-raw = (self.mouse-x - mouse-x-rel * (clamped-zoom / old-zoom)) / 1px;
                            image-container.pan-y-raw = (self.mouse-y - mouse-y-rel * (clamped-zoom / old-zoom)) / 1px;
                            image-container.zoom-level = clamped-zoom;
                            root.view-changed(image-container.pan-x-raw, image-container.pan-y-raw, image-container.zoom-level);
                            return accept;
                        }
                        reject
                    }
                }

                // Preview rectangle while drawing
                if root.show-preview: Rectangle {
                    x: image-container.pan-x + (root.preview-x * 1px * image-container.zoom-level);
                    y: image-container.pan-y + (root.preview-y * 1px * image-container.zoom-level);
                    width: root.preview-width * 1px * image-container.zoom-level;
                    height: root.preview-height * 1px * image-container.zoom-level;
                    border-width: 2px;
                    border-color: Theme.current.accent-primary;  // Cyan/blue for preview
                    background: Theme.current.accent-primary.with-alpha(0.13);  // Translucent
                }

                // Polygon mode indicator
                if root.polygon-mode-active: Rectangle {
                    x: 10px;
                    y: 50px;
                    width: 280px;
                    height: 40px;
                    background: Theme.current.accent-warning;
                    border-radius: 5px;

                    Text {
                        text: "POLYGON MODE (Hold S) - Click vertices, release S/Tab/Enter to finish, Esc to cancel";
                        color: Theme.current.bg-dark;
                        font-size: 10px;
                        horizontal-alignment: center;
                        vertical-alignment: center;
                    }
                }

                // Polygon preview - show lines as vertices are being added
                if root.polygon-mode-active && root.polygon-preview-path != "": Rectangle {
                    background: #00000000;
                    width: 100%;
                    height: 100%;

                    Path {
                        viewbox-width: root.image-source.width;
                        viewbox-height: root.image-source.height;
                        x: image-container.pan-x;
                        y: image-container.pan-y;
                        width: root.image-source.width * 1px * image-container.zoom-level;
                        height: root.image-source.height * 1px * image-container.zoom-level;

                        stroke: Theme.current.accent-warning;  // Yellow/warning color for preview
                        stroke-width: 2px;
                        fill: transparent;

                        commands: root.polygon-preview-path;
                    }
                }

                // Annotation Overlay
                for annotation[index] in root.annotations: annotation-rect := Rectangle {
                    background: #00000000; // Transparent
                    width: 100%;
                    height: 100%;

                    property <bool> hidden: annotation.state == "Rejected";
                    property <color> stroke-color: annotation.state == "Pending" ? Theme.current.pending : (annotation.state == "Manual" ? Theme.current.manual : Theme.current.accepted);
                    property <color> fill-color: annotation.state == "Pending" ? Theme.current.pending.with-alpha(0.13) : (annotation.state == "Manual" ? Theme.current.manual.with-alpha(0.13) : Theme.current.accepted.with-alpha(0.13));
                    
                    // Calculate screen coordinates
                    property <length> screen-x: image-container.pan-x + (annotation.x * 1px * image-container.zoom-level);
                    property <length> screen-y: image-container.pan-y + (annotation.y * 1px * image-container.zoom-level);
                    property <length> screen-w: annotation.width * 1px * image-container.zoom-level;
                    property <length> screen-h: annotation.height * 1px * image-container.zoom-level;
                    
                    // Rotation properties
                    property <angle> rot: annotation.rotation * 1deg;
                    
                    // Center and Half-dims
                    property <length> cx: self.screen-x + self.screen-w / 2;
                    property <length> cy: self.screen-y + self.screen-h / 2;

                    // Selection Bounding Box (for TouchArea)
                property <length> sel-w: annotation.type == "point" ? 20px : self.screen-w;
                property <length> sel-h: annotation.type == "point" ? 20px : self.screen-h;

                    // Point (Circle)
                    Rectangle {
                        visible: !annotation-rect.hidden && annotation.type == "point";
                        x: annotation-rect.screen-x - 5px;
                        y: annotation-rect.screen-y - 5px;
                        width: 10px;
                        height: 10px;
                        border-radius: 5px;
                        background: annotation.selected ? Theme.current.selected : annotation-rect.stroke-color;
                    }

                    // Standard BBox (Rectangle)
                    Rectangle {
                        visible: !annotation-rect.hidden && annotation.type == "bbox";
                        x: annotation-rect.screen-x;
                        y: annotation-rect.screen-y;
                        width: annotation-rect.screen-w;
                        height: annotation-rect.screen-h;
                        border-width: 2px;
                        border-color: annotation.selected ? Theme.current.selected : annotation-rect.stroke-color;
                        background: annotation.selected ? Theme.current.selected.with-alpha(0.13) : annotation-rect.fill-color;
                    }

                    // Rotated BBox (using transform-rotation)
                    Rectangle {
                        visible: !annotation-rect.hidden && annotation.type == "rbbox";
                        x: annotation-rect.screen-x;
                        y: annotation-rect.screen-y;
                        width: annotation-rect.screen-w;
                        height: annotation-rect.screen-h;
                        border-width: 2px;
                        border-color: annotation.selected ? Theme.current.selected : annotation-rect.stroke-color;
                        background: annotation.selected ? Theme.current.selected.with-alpha(0.13) : annotation-rect.fill-color;
                        transform-rotation: annotation-rect.rot;
                    }

                    // Polygon rendering - draw actual connected edges
                    if !annotation-rect.hidden && annotation.type == "polygon" && annotation.polygon-path-commands != "": Rectangle {
                        background: #00000000;
                        width: 100%;
                        height: 100%;

                        // Draw polygon with actual edges using Path
                        Path {
                            viewbox-width: root.image-source.width;
                            viewbox-height: root.image-source.height;
                            x: image-container.pan-x;
                            y: image-container.pan-y;
                            width: root.image-source.width * 1px * image-container.zoom-level;
                            height: root.image-source.height * 1px * image-container.zoom-level;

                            stroke: annotation.selected ? Theme.current.selected : annotation-rect.stroke-color;
                            stroke-width: 3px;
                            fill: annotation.selected ? Theme.current.selected.with-alpha(0.13) : annotation-rect.fill-color;

                            // Use dynamically generated SVG path commands
                            commands: annotation.polygon-path-commands;
                        }

                        // Draw vertex dots for clarity
                        for vertex in annotation.polygon-vertices: Rectangle {
                            x: image-container.pan-x + (vertex.x * 1px * image-container.zoom-level) - 5px;
                            y: image-container.pan-y + (vertex.y * 1px * image-container.zoom-level) - 5px;
                            width: 10px;
                            height: 10px;
                            border-radius: 5px;
                            background: annotation.selected ? Theme.current.selected : annotation-rect.stroke-color;
                        }
                    }

                    // Class label (shows class number)
                    Rectangle {
                        visible: !annotation-rect.hidden;
                        x: annotation-rect.screen-x;
                        y: annotation-rect.screen-y - 20px;
                        width: 32px;
                        height: 18px;
                        background: annotation.selected ? Theme.current.selected : annotation-rect.stroke-color;
                        border-radius: 3px;

                        Text {
                            text: annotation.class;
                            color: Theme.current.bg-dark;
                            font-size: 12px;
                            horizontal-alignment: center;
                            vertical-alignment: center;
                        }
                    }

                    // Resize handles (only for selected bbox/rbbox, not in polygon mode)
                    if annotation.selected && !annotation-rect.hidden && (annotation.type == "bbox" || annotation.type == "rbbox") && !root.polygon-mode-active: Rectangle {
                        property <length> handle-size: 8px;
                        property <length> half-handle: self.handle-size / 2;
                        background: #00000000;
                        width: 100%;
                        height: 100%;

                        // Corner handles
                        // Top-left
                        Rectangle {
                            x: annotation-rect.screen-x - parent.half-handle;
                            y: annotation-rect.screen-y - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: Theme.current.selected;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: nwse-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "corner-tl");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }

                        // Top-right
                        Rectangle {
                            x: annotation-rect.screen-x + annotation-rect.screen-w - parent.half-handle;
                            y: annotation-rect.screen-y - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: Theme.current.selected;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: nesw-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "corner-tr");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }

                        // Bottom-left
                        Rectangle {
                            x: annotation-rect.screen-x - parent.half-handle;
                            y: annotation-rect.screen-y + annotation-rect.screen-h - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: Theme.current.selected;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: nesw-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "corner-bl");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }

                        // Bottom-right
                        Rectangle {
                            x: annotation-rect.screen-x + annotation-rect.screen-w - parent.half-handle;
                            y: annotation-rect.screen-y + annotation-rect.screen-h - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: Theme.current.selected;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: nwse-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "corner-br");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }

                        // Edge handles
                        // Top edge
                        Rectangle {
                            x: annotation-rect.screen-x + annotation-rect.screen-w / 2 - parent.half-handle;
                            y: annotation-rect.screen-y - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: Theme.current.selected;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: ns-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "edge-t");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }

                        // Right edge
                        Rectangle {
                            x: annotation-rect.screen-x + annotation-rect.screen-w - parent.half-handle;
                            y: annotation-rect.screen-y + annotation-rect.screen-h / 2 - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: Theme.current.selected;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: ew-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "edge-r");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }

                        // Bottom edge
                        Rectangle {
                            x: annotation-rect.screen-x + annotation-rect.screen-w / 2 - parent.half-handle;
                            y: annotation-rect.screen-y + annotation-rect.screen-h - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: Theme.current.selected;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: ns-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "edge-b");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }

                        // Left edge
                        Rectangle {
                            x: annotation-rect.screen-x - parent.half-handle;
                            y: annotation-rect.screen-y + annotation-rect.screen-h / 2 - parent.half-handle;
                            width: parent.handle-size;
                            height: parent.handle-size;
                            background: Theme.current.selected;
                            border-width: 1px;
                            border-color: #000000;

                            TouchArea {
                                mouse-cursor: ew-resize;
                                pointer-event(event) => {
                                    if (event.button == PointerEventButton.left) {
                                        if (event.kind == PointerEventKind.down) {
                                            root.start-resize(index, "edge-l");
                                            root.is-resizing = true;
                                        } else if (event.kind == PointerEventKind.up) {
                                            root.finish-resize();
                                            root.is-resizing = false;
                                        }
                                    }
                                }
                                moved => {
                                    if (self.pressed && root.is-resizing) {
                                        let img-x = (self.mouse-x + parent.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                        let img-y = (self.mouse-y + parent.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                        root.update-resize(img-x, img-y);
                                    }
                                }
                            }
                        }
                    }

                    // Only intercept clicks when NOT in polygon mode
                    if !root.polygon-mode-active: TouchArea {
                        visible: !annotation-rect.hidden;
                        x: annotation-rect.cx - annotation-rect.sel-w / 2;
                        y: annotation-rect.cy - annotation-rect.sel-h / 2;
                        width: annotation-rect.sel-w;
                        height: annotation-rect.sel-h;
                        clicked => {
                            if (root.a-key-held) {
                                // Auto-resize gesture directly on annotation hit area
                                let img-x = (self.mouse-x + self.x - image-container.pan-x) / image-container.zoom-level / 1px;
                                let img-y = (self.mouse-y + self.y - image-container.pan-y) / image-container.zoom-level / 1px;
                                root.auto-resize-annotation(img-x, img-y, "AClick");
                            } else if (root.q-key-held) {
                                // Delete mode
                                root.delete-annotation(index);
                            } else if (root.digit-key-held) {
                                // Reclassify mode - change annotation's class
                                root.classify-at(annotation.x, annotation.y, root.current-class);
                            } else {
                                // Normal mode - select annotation
                                root.select-annotation(index);
                            }
                        }
                        double-clicked => {
                            root.delete-annotation(index);
                        }
                    }
                }
            }
        }

        // Bottom Status Bar (combined with navigation)
        Rectangle {
            height: 32px;
            background: Theme.current.bg-medium;
            HorizontalLayout {
                padding: 6px;
                spacing: 12px;

                // Dataset position
                Text {
                    text: root.dataset-position == "" ? "No dataset" : root.dataset-position;
                    color: Theme.current.text-secondary;
                    font-size: 12px;
                    vertical-alignment: center;
                    width: 60px;
                }

                Rectangle {
                    width: 1px;
                    height: 20px;
                    background: Theme.current.border-light;
                }

                // Image name
                Text {
                    text: root.current-image-name;
                    color: Theme.current.text-secondary;
                    font-size: 12px;
                    vertical-alignment: center;
                }

                Rectangle {
                    width: 1px;
                    height: 20px;
                    background: Theme.current.border-light;
                }

                // Status text
                Text {
                    text: root.status-text;
                    color: Theme.current.text-primary;
                    font-size: 12px;
                    vertical-alignment: center;
                }

                // Spacer
                Rectangle { }

                // Tool and class info
                Text {
                    text: "Tool: " + root.current-tool;
                    color: root.current-tool == "Neutral" ? Theme.current.text-disabled : Theme.current.accent-secondary;
                    font-size: 12px;
                    vertical-alignment: center;
                }

                Text {
                    text: "Class: " + root.current-class;
                    color: Theme.current.accent-warning;
                    font-size: 12px;
                    vertical-alignment: center;
                }

                // Navigation arrows
                HorizontalLayout {
                    spacing: 4px;

                    Rectangle {
                        width: 26px;
                        height: 20px;
                        background: prev-touch.has-hover ? Theme.current.bg-hover : Theme.current.bg-light;
                        border-radius: 3px;

                        Text {
                            text: "<";
                            color: Theme.current.text-primary;
                            horizontal-alignment: center;
                            vertical-alignment: center;
                        }

                        prev-touch := TouchArea {
                            clicked => {
                                root.prev-image();
                            }
                        }
                    }

                    Rectangle {
                        width: 26px;
                        height: 20px;
                        background: next-touch.has-hover ? Theme.current.bg-hover : Theme.current.bg-light;
                        border-radius: 3px;

                        Text {
                            text: ">";
                            color: Theme.current.text-primary;
                            horizontal-alignment: center;
                            vertical-alignment: center;
                        }

                        next-touch := TouchArea {
                            clicked => {
                                root.next-image();
                            }
                        }
                    }
                }
            }
        }
    }

    // Click outside to close menu (rendered before dropdowns so dropdowns appear on top)
    if root.open-menu != "": Rectangle {
        width: 100%;
        height: 100%;
        y: 32px;

        TouchArea {
            clicked => {
                root.open-menu = "";
            }
        }
    }

    // Menu Dropdowns (rendered last so they appear on top)
    // File Menu Dropdown
    if root.open-menu == "file": Rectangle {
        x: 0px;
        y: 32px;
        width: 220px;
        background: Theme.current.bg-light;
        border-width: 1px;
        border-color: Theme.current.border-light;

        VerticalLayout {
            padding: 4px;
            spacing: 2px;

            Rectangle {
                height: 28px;
                background: menu-open-touch.has-hover ? Theme.current.bg-hover : transparent;

                Text {
                    text: "Open Dataset...";
                    color: Theme.current.text-primary;
                    font-size: 13px;
                    x: 8px;
                    vertical-alignment: center;
                }

                menu-open-touch := TouchArea {
                    clicked => {
                        root.open-menu = "";
                        root.open-dataset();
                    }
                }
            }

            Rectangle {
                height: 28px;
                background: menu-new-touch.has-hover ? Theme.current.bg-hover : transparent;

                Text {
                    text: "New Dataset from Folder...";
                    color: Theme.current.text-primary;
                    font-size: 13px;
                    x: 8px;
                    vertical-alignment: center;
                }

                menu-new-touch := TouchArea {
                    clicked => {
                        root.open-menu = "";
                        root.new-dataset();
                    }
                }
            }

            Rectangle {
                height: 1px;
                background: Theme.current.border-light;
            }

            Rectangle {
                height: 28px;
                background: menu-save-touch.has-hover ? Theme.current.bg-hover : transparent;

                HorizontalLayout {
                    padding-left: 8px;
                    padding-right: 8px;

                    Text {
                        text: "Save";
                        color: Theme.current.text-primary;
                        font-size: 13px;
                        vertical-alignment: center;
                    }

                    Rectangle { }

                    Text {
                        text: "Ctrl+S";
                        color: Theme.current.text-secondary;
                        font-size: 11px;
                        vertical-alignment: center;
                    }
                }

                menu-save-touch := TouchArea {
                    clicked => {
                        root.open-menu = "";
                        root.save-dataset();
                    }
                }
            }

            Rectangle {
                height: 1px;
                background: Theme.current.border-light;
            }

            Rectangle {
                height: 28px;
                background: menu-export-coco-touch.has-hover ? Theme.current.bg-hover : transparent;

                Text {
                    text: "Export as COCO JSON...";
                    color: Theme.current.text-primary;
                    font-size: 13px;
                    x: 8px;
                    vertical-alignment: center;
                }

                menu-export-coco-touch := TouchArea {
                    clicked => {
                        root.open-menu = "";
                        root.export-coco();
                    }
                }
            }

            Rectangle {
                height: 28px;
                background: menu-export-voc-touch.has-hover ? Theme.current.bg-hover : transparent;

                Text {
                    text: "Export as Pascal VOC...";
                    color: Theme.current.text-primary;
                    font-size: 13px;
                    x: 8px;
                    vertical-alignment: center;
                }

                menu-export-voc-touch := TouchArea {
                    clicked => {
                        root.open-menu = "";
                        root.export-voc();
                    }
                }
            }
        }
    }

    // View Menu Dropdown
    if root.open-menu == "view": Rectangle {
        x: 60px;
        y: 32px;
        width: 160px;
        background: Theme.current.bg-light;
        border-width: 1px;
        border-color: Theme.current.border-light;

        VerticalLayout {
            padding: 4px;
            spacing: 2px;

            Rectangle {
                height: 28px;
                background: menu-reset-touch.has-hover ? Theme.current.bg-hover : transparent;

                HorizontalLayout {
                    padding-left: 8px;
                    padding-right: 8px;

                    Text {
                        text: "Reset View";
                        color: Theme.current.text-primary;
                        font-size: 13px;
                        vertical-alignment: center;
                    }

                    Rectangle { }

                    Text {
                        text: "H";
                        color: Theme.current.text-secondary;
                        font-size: 11px;
                        vertical-alignment: center;
                    }
                }

                menu-reset-touch := TouchArea {
                    clicked => {
                        root.open-menu = "";
                        root.reset-view();
                    }
                }
            }

            Rectangle {
                height: 28px;
                background: menu-sidebar-touch.has-hover ? Theme.current.bg-hover : transparent;

                Text {
                    text: "Toggle Sidebar";
                    color: Theme.current.text-primary;
                    font-size: 13px;
                    x: 8px;
                    vertical-alignment: center;
                }

                menu-sidebar-touch := TouchArea {
                    clicked => {
                        root.open-menu = "";
                        root.sidebar-visible = !root.sidebar-visible;
                    }
                }
            }

            Rectangle {
                height: 1px;
                background: Theme.current.border-light;
            }

            Rectangle {
                height: 28px;
                background: menu-dark-touch.has-hover ? Theme.current.bg-hover : transparent;

                Text {
                    text: "Dark Theme";
                    color: Theme.current.text-primary;
                    font-size: 13px;
                    x: 8px;
                    vertical-alignment: center;
                }

                menu-dark-touch := TouchArea {
                    clicked => {
                        root.open-menu = "";
                        Theme.set-theme("dark");
                    }
                }
            }

            Rectangle {
                height: 28px;
                background: menu-light-touch.has-hover ? Theme.current.bg-hover : transparent;

                Text {
                    text: "Light Theme";
                    color: Theme.current.text-primary;
                    font-size: 13px;
                    x: 8px;
                    vertical-alignment: center;
                }

                menu-light-touch := TouchArea {
                    clicked => {
                        root.open-menu = "";
                        Theme.set-theme("light");
                    }
                }
            }
        }
    }

    // Tools Menu Dropdown
    if root.open-menu == "tools": Rectangle {
        x: 120px;
        y: 32px;
        width: 160px;
        background: Theme.current.bg-light;
        border-width: 1px;
        border-color: Theme.current.border-light;

        VerticalLayout {
            padding: 4px;
            spacing: 2px;

            Rectangle {
                height: 28px;
                background: menu-settings-touch.has-hover ? Theme.current.bg-hover : transparent;

                Text {
                    text: "Settings...";
                    color: Theme.current.text-primary;
                    font-size: 13px;
                    x: 8px;
                    vertical-alignment: center;
                }

                menu-settings-touch := TouchArea {
                    clicked => {
                        root.open-menu = "";
                        root.settings-dialog-visible = true;
                    }
                }
            }
        }
    }

    // Settings Dialog
    SettingsDialog {
        show-dialog: root.settings-dialog-visible;
        theme-selection: root.theme-setting;
        enable-points: root.enable-points-setting;
        enable-bboxes: root.enable-bboxes-setting;
        enable-polygons: root.enable-polygons-setting;
        randomize-dataset: root.randomize-dataset-setting;
        apply-settings => {
            // Update settings
            root.theme-setting = self.theme-selection;
            root.enable-points-setting = self.enable-points;
            root.enable-bboxes-setting = self.enable-bboxes;
            root.enable-polygons-setting = self.enable-polygons;
            root.randomize-dataset-setting = self.randomize-dataset;

            // Apply theme immediately
            Theme.set-theme(root.theme-setting);

            // Call Rust callback to save settings
            root.apply-settings(
                root.theme-setting,
                root.enable-points-setting,
                root.enable-bboxes-setting,
                root.enable-polygons-setting,
                root.randomize-dataset-setting
            );

            // Close dialog
            root.settings-dialog-visible = false;
        }
        cancel => {
            root.settings-dialog-visible = false;
        }
    }

    // Reset view to fit the image in the container
    reset-view => {
        if (image-container.width <= 0px || image-container.height <= 0px || root.image-source.width <= 0 || root.image-source.height <= 0) {
            return;
        }
        let fs = max(0.1, image-container.fit-scale);
        root.view-zoom = fs;
        root.view-pan-x = (image-container.width - (root.image-source.width * 1px * fs)) / 2 / 1px;
        root.view-pan-y = (image-container.height - (root.image-source.height * 1px * fs)) / 2 / 1px;
        root.view-changed(root.view-pan-x, root.view-pan-y, root.view-zoom);
    }

    // Center the image for a given zoom, keeping pan consistent.
    apply-zoom-centered(zoom) => {
        if (image-container.width <= 0px || image-container.height <= 0px || root.image-source.width <= 0 || root.image-source.height <= 0) {
            return;
        }
        let z = max(0.1, zoom);
        root.view-zoom = z;
        // Center image within container for this zoom.
        root.view-pan-x = (image-container.width - (root.image-source.width * 1px * z)) / 2 / 1px;
        root.view-pan-y = (image-container.height - (root.image-source.height * 1px * z)) / 2 / 1px;
        root.view-changed(root.view-pan-x, root.view-pan-y, root.view-zoom);
    }

    // Keyboard handler (must be at root level)
    FocusScope {
        key-pressed(event) => {
            if (event.text == " " && event.modifiers.shift) {
                root.prev-image();
                accept
            } else if (event.text == " ") {
                root.next-image();
                accept
            } else if (event.text == "Left" || event.text == "ArrowLeft") {
                root.prev-image();
                accept
            } else if (event.text == "Right" || event.text == "ArrowRight") {
                root.next-image();
                accept
            } else if ((event.text == "0" && (event.modifiers.control || event.modifiers.meta)) || event.text == "h" || event.text == "H") {
                root.reset-view();
                accept
            } else if ((event.text == "s" || event.text == "S") && (event.modifiers.control || event.modifiers.meta)) {
                root.save-dataset();
                accept
            } else if (event.text == "b" || event.text == "B") {
                root.current-tool = "BBox (B)";
                accept
            } else if (event.text == "c" || event.text == "C") {
                root.current-tool = "Point (C)";
                accept
            } else if (event.text == "a" || event.text == "A") {
                root.a-key-held = true;
                accept
            } else if (event.text == "s" || event.text == "S") {
                            // S key press: activate polygon mode while held
                            if (!root.polygon-mode-active) {
                    root.polygon-mode-active = true;
                    root.current-tool = "Polygon (Hold S)";
                }
                root.s-key-held = true;
                accept
            } else if (event.text == "q" || event.text == "Q") {
                            // Cancel polygon if in mode, otherwise hold for delete
                if (root.polygon-mode-active) {
                    root.cancel-polygon();
                } else {
                    root.q-key-held = true;
                }
                accept
            } else if (event.text == "1") {
                root.current-class = 1;
                root.classify-selected(root.current-class);
                root.digit-key-held = true;
                accept
            } else if (event.text == "2") {
                root.current-class = 2;
                root.classify-selected(root.current-class);
                root.digit-key-held = true;
                accept
            } else if (event.text == "3") {
                root.current-class = 3;
                root.classify-selected(root.current-class);
                root.digit-key-held = true;
                accept
            } else if (event.text == "4") {
                root.current-class = 4;
                root.classify-selected(root.current-class);
                root.digit-key-held = true;
                accept
            } else if (event.text == "5") {
                root.current-class = 5;
                root.classify-selected(root.current-class);
                root.digit-key-held = true;
                accept
            } else if (event.text == "\n") {
                // Enter key - finish polygon
                if (root.polygon-mode-active) {
                    root.finish-polygon();
                    if (root.s-key-held) {
                        // Keep mode active while S is held
                        root.polygon-mode-active = true;
                        root.current-tool = "Polygon (Hold S)";
                    }
                    accept
                }
                reject
            } else if (event.text == "\u{0009}") {
                // Tab key - finish polygon
                if (root.polygon-mode-active) {
                    root.finish-polygon();
                    if (root.s-key-held) {
                        // Keep mode active while S is held
                        root.polygon-mode-active = true;
                        root.current-tool = "Polygon (Hold S)";
                    }
                    accept
                }
                reject
            } else if (event.text == "\u{001b}") {
                // Escape key - cancel polygon or exit polygon mode
                if (root.polygon-mode-active) {
                    root.cancel-polygon();
                }
                accept
            }
            reject
        }

        key-released(event) => {
            if (event.text == "b" || event.text == "B" || event.text == "c" || event.text == "C") {
                root.current-tool = "Neutral";
                accept
            } else if (event.text == "a" || event.text == "A") {
                root.a-key-held = false;
                accept
            } else if (event.text == "s" || event.text == "S") {
                    // S key release: finish any in-progress polygon and exit mode
                    if (root.polygon-mode-active) {
                    root.finish-polygon();
                }
                root.polygon-mode-active = false;
                root.current-tool = "Neutral";
                root.s-key-held = false;
                accept
            } else if (event.text == "q" || event.text == "Q") {
                root.q-key-held = false;
                accept
            } else if (event.text == "1" || event.text == "2" || event.text == "3" || event.text == "4" || event.text == "5") {
                root.digit-key-held = false;
                accept
            }
            reject
        }
    }
}
