//! Core state types for the annotator.

use serde::{Deserialize, Serialize};
use std::path::PathBuf;

// Re-export Annotation from Slint-generated code (will be imported in main.rs)
// The Annotation type is generated by Slint and accessed via slint::include_modules!()

/// Entry in a dataset manifest JSON file
#[derive(Debug, Serialize, Deserialize)]
pub struct DatasetFileEntry {
    pub image: String,
    pub labels: Option<String>,
}

/// Dataset manifest file structure
#[derive(Debug, Serialize, Deserialize)]
pub struct DatasetFile {
    pub images: Vec<DatasetFileEntry>,
}

/// A single dataset entry with resolved paths
#[derive(Debug, Clone)]
pub struct DatasetEntry {
    pub image_path: PathBuf,
    pub labels_path: Option<PathBuf>,
}

/// View state for pan and zoom
#[derive(Debug, Clone, Default)]
pub struct ViewState {
    pub pan_x: f32,
    pub pan_y: f32,
    pub zoom: f32,
}

/// Serializable annotation format for JSON state files
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StoredAnnotation {
    pub id: i32,
    #[serde(rename = "type")]
    pub r#type: String,
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    pub rotation: f32,
    pub selected: bool,
    pub class: i32,
    pub state: String,
    pub vertices: String,
}

/// Full dataset state including all entries and cached data
#[derive(Debug, Clone)]
pub struct DatasetState {
    pub entries: Vec<DatasetEntry>,
    pub current_index: usize,
    pub stored_annotations: Vec<Option<Vec<crate::Annotation>>>,
    pub view_states: Vec<Option<ViewState>>,
    pub global_view: Option<ViewState>,
    pub last_view_image_size: Option<(f32, f32)>,
    pub completed_frames: Vec<bool>,
}

/// State for drawing operations (bbox, point creation)
pub struct DrawState {
    pub start_x: f32,
    pub start_y: f32,
    pub next_id: i32,
    pub polygon_vertices: Vec<(f32, f32)>,
}

impl DrawState {
    pub fn new() -> Self {
        Self {
            start_x: 0.0,
            start_y: 0.0,
            next_id: 100, // Start from 100 to avoid conflicts with test data
            polygon_vertices: Vec::new(),
        }
    }
}

impl Default for DrawState {
    fn default() -> Self {
        Self::new()
    }
}

/// State for resize operations on annotations
pub struct ResizeState {
    pub annotation_index: usize,
    pub handle_type: String, // "corner-tl", "corner-tr", "corner-bl", "corner-br", etc.
    pub original_x: f32,
    pub original_y: f32,
    pub original_width: f32,
    pub original_height: f32,
}

impl ResizeState {
    pub fn new() -> Self {
        Self {
            annotation_index: 0,
            handle_type: String::new(),
            original_x: 0.0,
            original_y: 0.0,
            original_width: 0.0,
            original_height: 0.0,
        }
    }
}

impl Default for ResizeState {
    fn default() -> Self {
        Self::new()
    }
}

/// Undo/Redo history manager
#[derive(Debug, Clone)]
pub struct UndoHistory {
    undo_stack: Vec<Vec<crate::Annotation>>,
    redo_stack: Vec<Vec<crate::Annotation>>,
    max_history: usize,
}

impl UndoHistory {
    pub fn new(max_history: usize) -> Self {
        Self {
            undo_stack: Vec::new(),
            redo_stack: Vec::new(),
            max_history,
        }
    }

    /// Push current state onto undo stack (call BEFORE making a change)
    pub fn push(&mut self, snapshot: Vec<crate::Annotation>) {
        self.undo_stack.push(snapshot);

        // Limit history size
        if self.undo_stack.len() > self.max_history {
            self.undo_stack.remove(0);
        }

        // Clear redo stack when new action is performed
        self.redo_stack.clear();
    }

    /// Undo: pop from undo stack, push current to redo stack, return previous state
    pub fn undo(&mut self, current: Vec<crate::Annotation>) -> Option<Vec<crate::Annotation>> {
        if let Some(previous) = self.undo_stack.pop() {
            self.redo_stack.push(current);
            Some(previous)
        } else {
            None
        }
    }

    /// Redo: pop from redo stack, push current to undo stack, return next state
    pub fn redo(&mut self, current: Vec<crate::Annotation>) -> Option<Vec<crate::Annotation>> {
        if let Some(next) = self.redo_stack.pop() {
            self.undo_stack.push(current);
            Some(next)
        } else {
            None
        }
    }

    pub fn can_undo(&self) -> bool {
        !self.undo_stack.is_empty()
    }

    pub fn can_redo(&self) -> bool {
        !self.redo_stack.is_empty()
    }

    pub fn clear(&mut self) {
        self.undo_stack.clear();
        self.redo_stack.clear();
    }
}
